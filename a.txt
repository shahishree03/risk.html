// Vulnerability Dashboard Visualizations
const dataUrl = 'data/output.json'; // Use the correct data file

// Configuration for data sources
const config = {
    useLocalData: true, // Use local output.json for most visualizations
    useVendorAPI: true, // Use external API only for vendor product data
    vendorApiBase: 'https://raw.githubusercontent.com/shahishree03/Vendor_Product/refs/heads/master/JSON/',
    // API configuration for vulnerability trends
    vulnerabilityTrendsAPI: {
        enabled: true,
        baseUrl: 'https://api.vulnerability-trends.com/v1/trends', // Replace with your actual API endpoint
        endpoints: {
            trends: '/data',
            summary: '/summary'
        }
    }
};

// Function to fetch vulnerability trends data from API
async function fetchVulnerabilityTrendsFromAPI() {
    try {
        const apiUrl = `${config.vulnerabilityTrendsAPI.baseUrl}${config.vulnerabilityTrendsAPI.endpoints.trends}`;
        console.log('Fetching vulnerability trends from API:', apiUrl);
        
        const response = await fetch(apiUrl, {
            headers: {
                'Accept': 'application/json',
                'Content-Type': 'application/json'
            }
        });
        
        if (!response.ok) {
            throw new Error(`API request failed: ${response.status} ${response.statusText}`);
        }
        
        const apiData = await response.json();
        console.log('Vulnerability trends API data loaded:', apiData.length || 0, 'items');
        
        // Process and normalize API data to match expected format
        return processVulnerabilityData(apiData);
    } catch (error) {
        console.warn('Failed to fetch vulnerability trends from API, falling back to local data:', error);
        // Fallback to local data if API fails
        return await fetchLocalVulnerabilityData();
    }
}

// Function to fetch local vulnerability data (fallback)
async function fetchLocalVulnerabilityData() {
    try {
        const response = await fetch(dataUrl);
        const rawData = await response.json();
        return processVulnerabilityData(rawData);
    } catch (error) {
        console.error('Error fetching local vulnerability data:', error);
        return [];
    }
}

// Global variables for data and filters
let globalData = [];
let vulnerabilityTrendsData = []; // Separate data for trends from API
let currentFilters = {
    timePeriod: 'monthly',
    dateType: 'Published',
    cisaKev: 'all', // Changed to match HTML default (CISA KEV "all" is checked by default)
    severities: ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW'],
    geography: 'all', // Changed to match HTML default
    epssRange: [0, 100],
    cvssRange: [0, 10],
    exploitMaturity: ['Poc', 'Unreported','Attacked'],
    riskScoreRange: [0, 100], // Add risk score range filter
    dateRange: {
        startDate: null,
        endDate: null
    }
};

// Function to calculate severity based on CVSS score
function calculateSeverity(cvssScore) {
    const score = parseFloat(cvssScore);
    if (score >= 9.0) {
        return 'CRITICAL';
    } else if (score >= 7.0) {
        return 'HIGH';
    } else if (score >= 4.0) {
        return 'MEDIUM';
    } else {
        return 'LOW';
    }
}

// Function to process vulnerability data and add severity
function processVulnerabilityData(data) {
    return data.map(item => {
        // Handle different data formats
        let processedItem = { ...item };
        
        // If we have cvss_score, calculate severity
        if (item.cvss_score !== undefined && item.cvss_score !== null) {
            processedItem.severity = processedItem.severity || calculateSeverity(item.cvss_score);
        } else if (item.CVSS_Score !== undefined && item.CVSS_Score !== null) {
            processedItem.severity = calculateSeverity(item.CVSS_Score);
            processedItem.cvss_score = item.CVSS_Score;
        }
        
        // Ensure consistent field naming for compatibility
        processedItem.cve_id = item.CVE_ID || item.cve_id;
        processedItem.cvss_score = item.CVSS_Score || item.cvss_score;
        processedItem.epss_score = item.EPSS_Score || item.epss_score;
        processedItem.published_date = item.Published || item.published_date;
        processedItem.last_modified_date = item.Last_Modified || item.last_modified_date; // Fix: Map Last_Modified field
        processedItem.geography = item.Geography || item.geography;
        
        // Fix CISA KEV field - normalize to lowercase for consistent filtering
        const cisaKevValue = item.CISA_KEV || item.cisa_kev;
        processedItem.cisa_kev = cisaKevValue ? cisaKevValue.toString().toLowerCase() : null;
        
        processedItem.exploit_maturity = item.Exploit_Maturity || item.exploit_maturity;
        
        return processedItem;
    });
}

// Fetch and initialize data
async function fetchData() {
    try {
        // Fetch vulnerability trends data from API
        if (config.vulnerabilityTrendsAPI.enabled) {
            vulnerabilityTrendsData = await fetchVulnerabilityTrendsFromAPI();
        }
        
        // Fetch main dashboard data from local file (for other charts)
        const response = await fetch(dataUrl);
        const rawData = await response.json();
        const processedData = processVulnerabilityData(rawData);
        globalData = processedData;
        console.log('Main dashboard data loaded:', processedData.length, 'items');
        console.log('Vulnerability trends data loaded:', vulnerabilityTrendsData.length, 'items');
        return processedData;
    } catch (error) {
        console.error('Error fetching data:', error);
        return [];
    }
}

// Filter data based on current filters
function filterData(data) {
    return data.filter(item => {
        // CISA KEV filter - Fixed logic
        if (currentFilters.cisaKev !== 'all') {
            if (currentFilters.cisaKev === 'yes' && item.cisa_kev !== 'yes') return false;
            if (currentFilters.cisaKev === 'no' && item.cisa_kev === 'yes') return false;
        }
        
        // Exploit Maturity filter - Added missing filter
        if (currentFilters.exploitMaturity && currentFilters.exploitMaturity.length > 0) {
            if (!currentFilters.exploitMaturity.includes(item.exploit_maturity)) {
                return false;
            }
        }
        
        // Severity filter
        if (item.severity && !currentFilters.severities.includes(item.severity)) {
            return false;
        }
        
        // Geography filter
        if (currentFilters.geography !== 'all' && item.geography !== currentFilters.geography) {
            return false;
        }
        
        // EPSS Score filter
        const epssScore = parseFloat(item.epss_score) || 0;
        if (epssScore < currentFilters.epssRange[0] || epssScore > currentFilters.epssRange[1]) {
            return false;
        }
        
        // CVSS Score filter
        const cvssScore = parseFloat(item.cvss_score) || 0;
        if (cvssScore < currentFilters.cvssRange[0] || cvssScore > currentFilters.cvssRange[1]) {
            return false;
        }
        
        // Risk Score filter - New filter for risk score range
        const riskScore = parseFloat(item.Risk_Score) || 0;
        if (riskScore < currentFilters.riskScoreRange[0] || riskScore > currentFilters.riskScoreRange[1]) {
            return false;
        }
        
        // Date range filter - Filter based on selected date type
        if (currentFilters.dateRange.startDate || currentFilters.dateRange.endDate) {
            let targetDate;
            
            // Select the appropriate date field based on current date type filter
            if (currentFilters.dateType === 'Published') {
                targetDate = new Date(item.published_date);
            } else if (currentFilters.dateType === 'modified') {
                // Handle DD-MM-YYYY format from Last_Modified field
                const dateStr = item.last_modified_date;
                if (dateStr && dateStr.includes('-') && dateStr.split('-')[0].length === 2) {
                    const parts = dateStr.split('-');
                    targetDate = new Date(`${parts[2]}-${parts[1]}-${parts[0]}`);
                } else {
                    targetDate = new Date(dateStr);
                }
            } else {
                targetDate = new Date(item.published_date); // Default fallback
            }
            
            // Skip invalid dates
            if (isNaN(targetDate.getTime())) {
                return false;
            }
            
            // Apply date range filters
            if (currentFilters.dateRange.startDate) {
                const startDate = new Date(currentFilters.dateRange.startDate);
                if (targetDate < startDate) return false;
            }
            
            if (currentFilters.dateRange.endDate) {
                const endDate = new Date(currentFilters.dateRange.endDate);
                if (targetDate > endDate) return false;
            }
        }
        
        return true;
    });
}

// Process data for vulnerability trends
function processVulnerabilityTrends(data) {
    const filteredData = filterData(data);
    const dateField = currentFilters.dateType === 'Published' ? 'published_date' : 
                     currentFilters.dateType === 'modified' ? 'last_modified_date' : 'published_date'; // Fix: Handle 'modified' value
    
    // Group data by time period and severity
    const grouped = {};
    
    filteredData.forEach(item => {
        const dateStr = item[dateField];
        if (!dateStr) return;
        
        // Parse the date - handle DD-MM-YYYY format
        let date;
        if (dateStr.includes('-') && dateStr.split('-')[0].length === 2) {
            // Handle DD-MM-YYYY format from Last_Modified field
            const parts = dateStr.split('-');
            date = new Date(`${parts[2]}-${parts[1]}-${parts[0]}`); // Convert to YYYY-MM-DD
        } else {
            date = new Date(dateStr);
        }
        
        if (isNaN(date.getTime())) return;
        
        let timeKey;
        
        switch (currentFilters.timePeriod) {
            case 'yearly':
                timeKey = date.getFullYear().toString();
                break;
            case 'monthly':
                timeKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                break;
            case 'weekly':
                const weekStart = new Date(date);
                weekStart.setDate(date.getDate() - date.getDay());
                timeKey = weekStart.toISOString().split('T')[0];
                break;
            default:
                timeKey = dateStr;
        }
        
        if (!grouped[timeKey]) {
            grouped[timeKey] = {};
        }
        
        const severity = item.severity;
        if (!grouped[timeKey][severity]) {
            grouped[timeKey][severity] = 0;
        }
        
        grouped[timeKey][severity]++;
    });
    
    // Convert to array format for D3
    const result = [];
    Object.keys(grouped).sort().forEach(timeKey => {
        const entry = { period: timeKey };
        ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW'].forEach(severity => {
            entry[severity] = grouped[timeKey][severity] || 0;
        });
        result.push(entry);
    });
    
    return result;
}

// Create vulnerability trends bar chart
function createVulnerabilityTrends(data) {
    // Clear previous chart
    d3.select('#vulnerability-trends-container').selectAll('*').remove();
    
    const processedData = processVulnerabilityTrends(data);
    
    if (processedData.length === 0) {
        d3.select('#vulnerability-trends-container')
            .append('p')
            .style('text-align', 'center')
            .style('color', '#666')
            .style('font-size', '14px')
            .style('margin', '20px')
            .text('No data available for current filters');
        return;
    }
    
    const margin = { top: 20, right: 120, bottom: 80, left: 60 };
    const width = 800 - margin.left - margin.right;
    const height = 400 - margin.top - margin.bottom;
    
    const svg = d3.select('#vulnerability-trends-container')
        .append('svg')
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom);
    
    const g = svg.append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);
    
    // Color scale for severities
    const colorScale = d3.scaleOrdinal()
        .domain(['CRITICAL', 'HIGH', 'MEDIUM', 'LOW'])
        .range(['#dc3545', '#fd7e14', '#ffc107', '#28a745']);
    
    // Stack the data
    const stack = d3.stack()
        .keys(['CRITICAL', 'HIGH', 'MEDIUM', 'LOW']);
    
    const stackedData = stack(processedData);
    
    // Scales
    const xScale = d3.scaleBand()
        .domain(processedData.map(d => d.period))
        .range([0, width])
        .padding(0.1);
    
    const yScale = d3.scaleLinear()
        .domain([0, d3.max(stackedData, d => d3.max(d, d => d[1]))])
        .nice()
        .range([height, 0]);
    
    // Create bars
    const layers = g.selectAll('.layer')
        .data(stackedData)
        .enter().append('g')
        .attr('class', 'layer')
        .style('fill', d => colorScale(d.key));
    
    layers.selectAll('rect')
        .data(d => d)
        .enter().append('rect')
        .attr('x', d => xScale(d.data.period))
        .attr('y', d => yScale(d[1]))
        .attr('height', d => yScale(d[0]) - yScale(d[1]))
        .attr('width', xScale.bandwidth())
        .on('mouseover', function(event, d) {
            // Tooltip
            const tooltip = d3.select('body').append('div')
                .attr('class', 'tooltip')
                .style('position', 'absolute')
                .style('background', 'rgba(0, 0, 0, 0.8)')
                .style('color', 'white')
                .style('padding', '8px')
                .style('border-radius', '4px')
                .style('font-size', '12px')
                .style('pointer-events', 'none')
                .style('z-index', '1000');
            
            const severity = d3.select(this.parentNode).datum().key;
            const count = d[1] - d[0];
            
            tooltip.html(`Period: ${d.data.period}<br>Severity: ${severity}<br>Count: ${count}`)
                .style('left', (event.pageX + 10) + 'px')
                .style('top', (event.pageY - 10) + 'px');
        })
        .on('mouseout', function() {
            d3.selectAll('.tooltip').remove();
        });
    
    // X axis
    g.append('g')
        .attr('transform', `translate(0,${height})`)
        .call(d3.axisBottom(xScale))
        .selectAll('text')
        .style('text-anchor', 'end')
        .attr('dx', '-.8em')
        .attr('dy', '.15em')
        .attr('transform', 'rotate(-45)');
    
    // Y axis
    g.append('g')
        .call(d3.axisLeft(yScale));
    
    // Labels
    g.append('text')
        .attr('transform', 'rotate(-90)')
        .attr('y', 0 - margin.left)
        .attr('x', 0 - (height / 2))
        .attr('dy', '1em')
        .style('text-anchor', 'middle')
        .style('font-size', '12px')
        .text('Number of Vulnerabilities');
    
    g.append('text')
        .attr('transform', `translate(${width / 2}, ${height + margin.bottom - 10})`)
        .style('text-anchor', 'middle')
        .style('font-size', '12px')
        .text(getTimePeriodLabel());
    
    // Legend
    const legend = svg.append('g')
        .attr('transform', `translate(${width + margin.left + 20}, ${margin.top})`);
    
    const legendItems = legend.selectAll('.legend-item')
        .data(['CRITICAL', 'HIGH', 'MEDIUM', 'LOW'])
        .enter().append('g')
        .attr('class', 'legend-item')
        .attr('transform', (d, i) => `translate(0, ${i * 20})`);
    
    legendItems.append('rect')
        .attr('width', 15)
        .attr('height', 15)
        .style('fill', d => colorScale(d));
    
    legendItems.append('text')
        .attr('x', 20)
        .attr('y', 12)
        .style('font-size', '12px')
        .text(d => d);
    
    // Title
    svg.append('text')
        .attr('x', (width + margin.left + margin.right) / 2)
        .attr('y', 20)
        .attr('text-anchor', 'middle')
        .style('font-size', '16px')
        .style('font-weight', 'bold')
        .text(`${getTimePeriodLabel()} Vulnerability Counts by Severity`);
}

function getTimePeriodLabel() {
    switch (currentFilters.timePeriod) {
        case 'yearly': return 'Year';
        case 'monthly': return 'Month';
        case 'weekly': return 'Week';
        default: return 'Time Period';
    }
}

// Update filter handlers
function setupFilterHandlers() {
    // Time period filter
    document.querySelectorAll('input[name="time-period"]').forEach(radio => {
        radio.addEventListener('change', (e) => {
            currentFilters.timePeriod = e.target.value;
            updateVisualization();
        });
    });
    
    // Date type filter with date range visibility toggle
    document.querySelectorAll('input[name="date-type"]').forEach(radio => {
        radio.addEventListener('change', (e) => {
            currentFilters.dateType = e.target.value;
            updateDateRangeTitle(e.target.value);
            updateVisualization();
        });
    });
    
    // CISA KEV filter - fix name mismatch
    document.querySelectorAll('input[name="cisa-kev"]').forEach(radio => {
        radio.addEventListener('change', (e) => {
            currentFilters.cisaKev = e.target.value;
            updateVisualization();
        });
    });
    
    // Severity filter - fix name and values mismatch
    document.querySelectorAll('input[name="severity"]').forEach(checkbox => {
        checkbox.addEventListener('change', () => {
            currentFilters.severities = Array.from(
                document.querySelectorAll('input[name="severity"]:checked')
            ).map(cb => cb.value.toUpperCase()); // Convert to uppercase to match our severity levels
            updateVisualization();
        });
    });
    
    // Geography filter - fix name mismatch
    document.querySelectorAll('input[name="geography"]').forEach(radio => {
        radio.addEventListener('change', (e) => {
            currentFilters.geography = e.target.value;
            updateVisualization();
        });
    });
    
    // Range sliders
    const epssMin = document.getElementById('epss-min');
    const epssMax = document.getElementById('epss-max');
    const cvssMin = document.getElementById('cvss-min');
    const cvssMax = document.getElementById('cvss-max');
    
    if (epssMin && epssMax) {
        [epssMin, epssMax].forEach(slider => {
            slider.addEventListener('input', () => {
                currentFilters.epssRange = [
                    parseFloat(epssMin.value),
                    parseFloat(epssMax.value)
                ];
                document.getElementById('epss-min-value').textContent = epssMin.value;
                document.getElementById('epss-max-value').textContent = epssMax.value;
                updateVisualization();
            });
        });
    }
    
    if (cvssMin && cvssMax) {
        [cvssMin, cvssMax].forEach(slider => {
            slider.addEventListener('input', () => {
                currentFilters.cvssRange = [
                    parseFloat(cvssMin.value),
                    parseFloat(cvssMax.value)
                ];
                document.getElementById('cvss-min-value').textContent = cvssMin.value;
                document.getElementById('cvss-max-value').textContent = cvssMax.value;
                updateVisualization();
            });
        });
    }
    
    // Exploit maturity filter - fix name mismatch
    document.querySelectorAll('input[name="exploit-maturity"]').forEach(checkbox => {
        checkbox.addEventListener('change', () => {
            currentFilters.exploitMaturity = Array.from(
                document.querySelectorAll('input[name="exploit-maturity"]:checked')
            ).map(cb => cb.value);
            updateVisualization();
        });
    });
    
    // Date range filter handlers
    setupDateRangeHandlers();
}

// Setup date range filter handlers
function setupDateRangeHandlers() {
    const startDateInput = document.getElementById('start-date');
    const endDateInput = document.getElementById('end-date');
    const clearButton = document.getElementById('clear-date-range');
    const applyButton = document.getElementById('apply-date-range');
    
    // Date input change handlers
    if (startDateInput && endDateInput) {
        [startDateInput, endDateInput].forEach(input => {
            input.addEventListener('change', () => {
                currentFilters.dateRange.startDate = startDateInput.value;
                currentFilters.dateRange.endDate = endDateInput.value;
                // Auto-update visualization when dates change
                updateVisualization();
            });
        });
    }
    
    // Clear button handler
    if (clearButton) {
        clearButton.addEventListener('click', () => {
            if (startDateInput) startDateInput.value = '';
            if (endDateInput) endDateInput.value = '';
            currentFilters.dateRange.startDate = null;
            currentFilters.dateRange.endDate = null;
            updateVisualization();
        });
    }
    
    // Apply button handler (for explicit apply if needed)
    if (applyButton) {
        applyButton.addEventListener('click', () => {
            updateVisualization();
        });
    }
}

// Update date range title based on selected date type
function updateDateRangeTitle(dateType) {
    const titleElement = document.getElementById('date-range-title');
    if (titleElement) {
        if (dateType === 'Published') {
            titleElement.textContent = 'Published Date Range';
        } else if (dateType === 'modified') {
            titleElement.textContent = 'Last Modified Date Range';
        }
    }
}

// Update visualization
function updateVisualization() {
    if (globalData.length > 0) {
        createVulnerabilityTrends(globalData);
        createAttackVectorChart(globalData);
        createCVSSDistributionChart(globalData);
        createVendorBubbleChart(globalData);
        updateSummaryStats(globalData);
        
        // Update CVE Risk heatmap if data is available
        if (allRiskData.length > 0) {
            drawCVERiskHeatmap();
        }
    }
}

// Process data for attack vector distribution
function processAttackVectorData(data) {
    const filteredData = filterData(data);
    
    // Count attack vectors
    const attackVectorCounts = {};
    
    filteredData.forEach(item => {
        // Handle different field names for attack vector
        let attackVector = item.Attack_Vector || item.attack_vector || 'Unknown';
        
        // Normalize attack vector names - handle common variations
        if (typeof attackVector === 'string') {
            attackVector = attackVector.trim();
            // Map common variations to standard names
            const vectorMap = {
                'network': 'Network',
                'Network': 'Network',
                'local': 'Local',
                'Local': 'Local',
                'physical': 'Physical',
                'Physical': 'Physical',
                'adjacent': 'Adjacent Network',
                'Adjacent': 'Adjacent Network',
                'adjacent_network': 'Adjacent Network'
            };
            attackVector = vectorMap[attackVector] || attackVector;
        } else {
            attackVector = 'Unknown';
        }
        
        if (!attackVectorCounts[attackVector]) {
            attackVectorCounts[attackVector] = 0;
        }
        attackVectorCounts[attackVector]++;
    });
    
    // Convert to array format for D3
    const result = Object.entries(attackVectorCounts)
        .map(([vector, count]) => ({
            attackVector: vector,
            count: count,
            percentage: 0 // Will be calculated later
        }))
        .sort((a, b) => b.count - a.count);
    
    // Calculate percentages
    const total = result.reduce((sum, item) => sum + item.count, 0);
    result.forEach(item => {
        item.percentage = total > 0 ? ((item.count / total) * 100).toFixed(1) : 0;
    });
    
    return result;
}

// Create attack vector pie chart
function createAttackVectorChart(data) {
    // Clear previous chart
    d3.select('#attack-vector-chart').selectAll('*').remove();
    
    const processedData = processAttackVectorData(data);
    
    if (processedData.length === 0) {
        d3.select('#attack-vector-chart')
            .append('p')
            .style('text-align', 'center')
            .style('color', '#666')
            .style('font-size', '12px')
            .style('margin', '10px')
            .text('No data available');
        return;
    }
    
    const width = 200;
    const height = 200;
    const radius = Math.min(width, height) / 2 - 20;
    
    const svg = d3.select('#attack-vector-chart')
        .append('svg')
        .attr('width', width)
        .attr('height', height);
    
    const g = svg.append('g')
        .attr('transform', `translate(${width / 2}, ${height / 2})`);
    
    // Color scale for attack vectors
    const colorScale = d3.scaleOrdinal()
        .domain(processedData.map(d => d.attackVector))
        .range(['#e74c3c', '#3498db', '#f39c12', '#2ecc71', '#9b59b6', '#1abc9c', '#f1c40f', '#34495e']);
    
    // Create pie layout
    const pie = d3.pie()
        .value(d => d.count)
        .sort(null);
    
    const arc = d3.arc()
        .innerRadius(radius * 0.3) // Create donut chart
        .outerRadius(radius);
    
    const arcs = g.selectAll('.arc')
        .data(pie(processedData))
        .enter().append('g')
        .attr('class', 'arc');
    
    // Add pie slices
    arcs.append('path')
        .attr('d', arc)
        .attr('fill', d => colorScale(d.data.attackVector))
        .attr('stroke', '#fff')
        .attr('stroke-width', 2)
        .on('mouseover', function(event, d) {
            // Create tooltip
            const tooltip = d3.select('body').append('div')
                .attr('class', 'tooltip')
                .style('position', 'absolute')
                .style('background', 'rgba(0, 0, 0, 0.8)')
                .style('color', 'white')
                .style('padding', '8px')
                .style('border-radius', '4px')
                .style('font-size', '12px')
                .style('pointer-events', 'none')
                .style('z-index', '1000');
            
            tooltip.html(`
                <strong>${d.data.attackVector}</strong><br>
                Count: ${d.data.count}<br>
                Percentage: ${d.data.percentage}%
            `)
                .style('left', (event.pageX + 10) + 'px')
                .style('top', (event.pageY - 10) + 'px');
        })
        .on('mouseout', function() {
            d3.selectAll('.tooltip').remove();
        });
    
    // Add center text showing total count
    const totalCount = processedData.reduce((sum, item) => sum + item.count, 0);
    g.append('text')
        .attr('text-anchor', 'middle')
        .attr('dy', '0.35em')
        .style('font-size', '14px')
        .style('font-weight', 'bold')
        .style('fill', '#333')
        .text(totalCount);
    
    g.append('text')
        .attr('text-anchor', 'middle')
        .attr('dy', '1.5em')
        .style('font-size', '10px')
        .style('fill', '#666')
        .text('Total');
    
    // Add legend
    const legend = svg.append('g')
        .attr('class', 'legend')
        .attr('transform', `translate(10, 10)`);
    
    const legendItems = legend.selectAll('.legend-item')
        .data(processedData.slice(0, 4)) // Show top 4 items in legend
        .enter().append('g')
        .attr('class', 'legend-item')
        .attr('transform', (d, i) => `translate(0, ${i * 15})`);
    
    legendItems.append('rect')
        .attr('width', 10)
        .attr('height', 10)
        .style('fill', d => colorScale(d.attackVector));
    
    legendItems.append('text')
        .attr('x', 15)
        .attr('y', 9)
        .style('font-size', '10px')
        .style('fill', '#333')
        .text(d => {
            const maxLength = 12;
            return d.attackVector.length > maxLength 
                ? d.attackVector.substring(0, maxLength) + '...' 
                : d.attackVector;
        });
    
    // Add title
    svg.append('text')
        .attr('x', width / 2)
        .attr('y', 15)
        .attr('text-anchor', 'middle')
        .style('font-size', '12px')
        .style('font-weight', 'bold')
        .style('fill', '#333')
        .text('Attack Vectors');
}

// Process data for CVSS score distribution
function processCVSSDistribution(data) {
    const filteredData = filterData(data);
    
    // Define CVSS score ranges
    const ranges = [
        { label: 'Low (0.1-3.9)', min: 0.1, max: 3.9, color: '#28a745' },
        { label: 'Medium (4.0-6.9)', min: 4.0, max: 6.9, color: '#ffc107' },
        { label: 'High (7.0-8.9)', min: 7.0, max: 8.9, color: '#fd7e14' },
        { label: 'Critical (9.0-10.0)', min: 9.0, max: 10.0, color: '#dc3545' }
    ];
    
    const result = ranges.map(range => ({
        ...range,
        count: 0
    }));
    
    filteredData.forEach(item => {
        const cvssScore = parseFloat(item.CVSS_Score || item.cvss_score);
        if (!isNaN(cvssScore)) {
            const range = ranges.find(r => cvssScore >= r.min && cvssScore <= r.max);
            if (range) {
                const resultRange = result.find(r => r.label === range.label);
                if (resultRange) {
                    resultRange.count++;
                }
            }
        }
    });
    
    // Calculate percentages
    const total = result.reduce((sum, item) => sum + item.count, 0);
    result.forEach(item => {
        item.percentage = total > 0 ? ((item.count / total) * 100).toFixed(1) : 0;
    });
    
    return result.filter(item => item.count > 0);
}

// Create CVSS score distribution pie chart
function createCVSSDistributionChart(data) {
    // Clear previous chart
    d3.select('#cvss-pie-chart').selectAll('*').remove();
    
    const processedData = processCVSSDistribution(data);
    
    if (processedData.length === 0) {
        d3.select('#cvss-pie-chart')
            .append('p')
            .style('text-align', 'center')
            .style('color', '#666')
            .style('font-size', '12px')
            .style('margin', '10px')
            .text('No data available');
        return;
    }
    
    const width = 200;
    const height = 200;
    const radius = Math.min(width, height) / 2 - 20;
    
    const svg = d3.select('#cvss-pie-chart')
        .append('svg')
        .attr('width', width)
        .attr('height', height);
    
    const g = svg.append('g')
        .attr('transform', `translate(${width / 2}, ${height / 2})`);
    
    // Create pie layout
    const pie = d3.pie()
        .value(d => d.count)
        .sort(null);
    
    const arc = d3.arc()
        .innerRadius(radius * 0.3)
        .outerRadius(radius);
    
    const arcs = g.selectAll('.arc')
        .data(pie(processedData))
        .enter().append('g')
        .attr('class', 'arc');
    
    // Add pie slices
    arcs.append('path')
        .attr('d', arc)
        .attr('fill', d => d.data.color)
        .attr('stroke', '#fff')
        .attr('stroke-width', 2)
        .on('mouseover', function(event, d) {
            const tooltip = d3.select('body').append('div')
                .attr('class', 'tooltip')
                .style('position', 'absolute')
                .style('background', 'rgba(0, 0, 0, 0.8)')
                .style('color', 'white')
                .style('padding', '8px')
                .style('border-radius', '4px')
                .style('font-size', '12px')
                .style('pointer-events', 'none')
                .style('z-index', '1000');
            
            tooltip.html(`
                <strong>${d.data.label}</strong><br>
                Count: ${d.data.count}<br>
                Percentage: ${d.data.percentage}%
            `)
                .style('left', (event.pageX + 10) + 'px')
                .style('top', (event.pageY - 10) + 'px');
        })
        .on('mouseout', function() {
            d3.selectAll('.tooltip').remove();
        });
    
    // Add center text
    const totalCount = processedData.reduce((sum, item) => sum + item.count, 0);
    g.append('text')
        .attr('text-anchor', 'middle')
        .attr('dy', '0.35em')
        .style('font-size', '14px')
        .style('font-weight', 'bold')
        .style('fill', '#333')
        .text(totalCount);
    
    g.append('text')
        .attr('text-anchor', 'middle')
        .attr('dy', '1.5em')
        .style('font-size', '10px')
        .style('fill', '#666')
        .text('Total');
}

// Determine which vendor data file to use based on filters (implement vendor.html logic)
function getVendorDataFile() {
    const cisaKev = currentFilters.cisaKev || 'all';
    const geography = currentFilters.geography || 'all';
    
    // Use the same logic as vendor.html
    if (cisaKev === 'yes') {
        if (geography === 'Impacted') {
            return 'CISA_KEV_YES__GEO_IMPACTED.json';
        } else if (geography === 'Not_impacted') {
            return 'CISA_KEV_YES__GEO_NOTIMPACTED.json';
        } else {
            return 'yes.json'; // CISA KEV yes, all geography
        }
    } else if (cisaKev === 'no') {
        if (geography === 'Impacted') {
            return 'CISA_KEV_NO__GEO_IMPACTED.json';
        } else if (geography === 'Not_impacted') {
            return 'CISA_KEV_NO__GEO_NOTIMPACTED.json';
        } else {
            return 'no.json'; // CISA KEV no, all geography
        }
    } else {
        // All CISA KEV values
        if (geography === 'Impacted') {
            return 'geoimpact.json';
        } else if (geography === 'Not_impacted') {
            return 'geo_noimpact.json';
        } else {
            return 'All.json'; // All data
        }
    }
}

// Fetch vendor data from external API with proper data file selection
async function fetchVendorData() {
    try {
        const base = config.vendorApiBase;
        const dataFile = getVendorDataFile();
        const url = base + dataFile;
        
        console.log('Fetching vendor data from:', url);
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        return data;
    } catch (error) {
        console.error('Error fetching vendor data:', error);
        return null;
    }
}

// Apply advanced filters to vendor data (implement vendor.html filtering)
function applyAdvancedFilters(vendorData) {
    if (!vendorData) return [];
    
    // Convert object to array if needed and map fields
    let data;
    if (!Array.isArray(vendorData)) {
        data = Object.entries(vendorData).map(([vendor, obj]) => ({
            vendor,
            total_count: obj.total_count || obj.total_counts,
            products: obj.subproducts || obj.products || {}
        }));
    } else {
        data = vendorData;
    }
    
    // Check if any advanced filters are enabled
    const hasActiveFilters = (
        (currentFilters.cvssRange[0] > 0 || currentFilters.cvssRange[1] < 10) ||
        (currentFilters.epssRange[0] > 0 || currentFilters.epssRange[1] < 100) ||
        (currentFilters.exploitMaturity && currentFilters.exploitMaturity.length > 0 && 
         currentFilters.exploitMaturity.length < 3) // Not all exploit types selected
    );
    
    if (!hasActiveFilters) {
        // No advanced filters active, return vendors with data
        return data.filter(vendor => vendor.total_count > 0);
    }
    
    // Apply CVSS, EPSS, and Exploit filters
    return data.map(vendor => {
        const newProducts = {};
        
        Object.entries(vendor.products || {}).forEach(([productName, productData]) => {
            let passesFilter = true;
            
            // Apply CVSS filter - only if range is not default (0-10)
            if (currentFilters.cvssRange[0] > 0 || currentFilters.cvssRange[1] < 10) {
                if (productData.cvss_scores && Array.isArray(productData.cvss_scores)) {
                    const cvssInRange = productData.cvss_scores.some(score => 
                        score >= currentFilters.cvssRange[0] && score <= currentFilters.cvssRange[1]
                    );
                    if (!cvssInRange) passesFilter = false;
                } else {
                    passesFilter = false;
                }
            }
            
            // Apply EPSS filter - only if range is not default (0-100)
            if (currentFilters.epssRange[0] > 0 || currentFilters.epssRange[1] < 100) {
                if (productData.epss_scores && Array.isArray(productData.epss_scores)) {
                    // Convert percentage to decimal for comparison with API data
                    const epssMin = currentFilters.epssRange[0] / 100;
                    const epssMax = currentFilters.epssRange[1] / 100;
                    const epssInRange = productData.epss_scores.some(score => 
                        score >= epssMin && score <= epssMax
                    );
                    if (!epssInRange) passesFilter = false;
                } else {
                    passesFilter = false;
                }
            }
            
            // Apply Exploit Maturity filter - only if not all types are selected
            if (currentFilters.exploitMaturity && currentFilters.exploitMaturity.length > 0 && 
                currentFilters.exploitMaturity.length < 3) {
                if (productData.exploit_maturity && productData.exploit_maturity.values) {
                    const exploitMatches = productData.exploit_maturity.values.some(maturity =>
                        currentFilters.exploitMaturity.includes(maturity)
                    );
                    if (!exploitMatches) passesFilter = false;
                } else {
                    passesFilter = false;
                }
            }
            
            if (passesFilter) {
                newProducts[productName] = productData;
            }
        });
        
        // Recalculate total count based on filtered products
        const newTotalCount = Object.values(newProducts).reduce((sum, product) => {
            return sum + (product.counts || product.count || 0);
        }, 0);
        
        return {
            ...vendor,
            products: newProducts,
            subproducts: newProducts,
            total_count: newTotalCount,
            total_counts: newTotalCount
        };
    }).filter(vendor => {
        // Only include vendors that have products after filtering AND have a count > 0
        return Object.keys(vendor.products || {}).length > 0 && vendor.total_count > 0;
    });
}

// Process data for vendor bubble chart
async function processVendorData(data) {
    try {
        const vendorData = await fetchVendorData();
        const filteredData = applyAdvancedFilters(vendorData);
        return filteredData;
    } catch (error) {
        console.error('Error processing vendor data:', error);
        return [];
    }
}

// Advanced bubble chart implementation from vendor.html
async function createVendorBubbleChart(data) {
    // Clear previous chart completely - remove all elements including tooltips
    d3.select('#vendor-bubble-container').selectAll('*').remove();
    d3.selectAll('.vendor-tooltip').remove(); // Remove any existing tooltips
    
    // Prevent multiple simultaneous calls
    if (createVendorBubbleChart.isRunning) {
        console.log('Vendor bubble chart already running, skipping...');
        return;
    }
    createVendorBubbleChart.isRunning = true;
    
    try {
        const processedData = await processVendorData(data);
        
        // Update total count display
        const totalCount = processedData.reduce((sum, vendor) => sum + vendor.total_count, 0);
        const vendorCountElement = document.getElementById('vendor-total-count');
        if (vendorCountElement) {
            vendorCountElement.textContent = `Total Count: ${totalCount}`;
        }
        
        if (!processedData || processedData.length === 0) {
            d3.select('#vendor-bubble-container')
                .append('div')
                .style('color', '#888')
                .style('text-align', 'center')
                .style('padding', '100px 0')
                .style('font-size', '1.5em')
                .text('No data to display for current filters.');
            return;
        }
        
        const width = 800;
        const height = 400;
        
        // Create single SVG container
        const svg = d3.select('#vendor-bubble-container')
            .append('svg')
            .attr('width', width)
            .attr('height', height)
            .style('cursor', 'pointer')
            .style('background', 'radial-gradient(ellipse at center, #f8fafc 0%, #e3e8ee 100%)');

        // Create tooltip only once
        const tooltip = d3.select('body').append('div')
            .attr('class', 'vendor-tooltip')
            .style('position', 'absolute')
            .style('background', '#fff')
            .style('border', '1px solid #ccc')
            .style('border-radius', '4px')
            .style('padding', '10px')
            .style('box-shadow', '0 2px 8px rgba(0,0,0,0.15)')
            .style('pointer-events', 'none')
            .style('font-size', '12px')
            .style('color', '#222')
            .style('line-height', '1.4')
            .style('max-width', '350px')
            .style('word-break', 'break-word')
            .style('z-index', '1000')
            .style('opacity', 0);

        // Helper: create vendor root - SINGLE GROUP ONLY
        function getVendorRoot() {
            return {
                name: 'root',
                children: processedData.map(vendor => ({
                    name: vendor.vendor,
                    value: vendor.total_count,
                    vendor: vendor.vendor,
                    children: null
                }))
            };
        }

        // Helper: create product root for a vendor
        function getProductRoot(vendorName) {
            const vendor = processedData.find(c => c.vendor === vendorName);
            if (!vendor) return getVendorRoot();
            
            let children = Object.entries(vendor.products)
                .map(([prod, prodObj]) => {
                    let value = (typeof prodObj === 'number') ? prodObj : (prodObj.counts || prodObj.value || 0);
                    return {
                        name: prod,
                        value: value,
                        vendor: vendor.vendor,
                        productData: prodObj
                    };
                });
            
            return {
                name: vendor.vendor,
                children: children
            };
        }

        let currentLevel = 'vendor';
        let currentVendor = null;

        // Helper functions for labels
        function isCircleFullyVisible(d, transform) {
            const k = transform ? transform.k : 1;
            const tx = transform ? transform.x : 0;
            const ty = transform ? transform.y : 0;
            const cx = d.x * k + tx;
            const cy = d.y * k + ty;
            const r = d.r * k;
            return (
                cx - r >= 0 &&
                cy - r >= 0 &&
                cx + r <= width &&
                cy + r <= height
            );
        }

        function getFittedFontSize(text, radius) {
            const maxFont = radius * 0.6;
            const minFont = 10;
            let fontSize = Math.min(maxFont, Math.max(minFont, (radius * 1.5) / (text.length * 0.6)));
            return fontSize;
        }

        function getNonOverlappingLabels(leaves, transform) {
            let shown = [];
            leaves = leaves.slice().sort((a, b) => b.r - a.r);
            for (let d of leaves) {
                if (!isCircleFullyVisible(d, transform)) continue;
                let overlap = shown.some(s => {
                    const k = transform ? transform.k : 1;
                    const tx = transform ? transform.x : 0;
                    const ty = transform ? transform.y : 0;
                    const dx = (d.x * k + tx) - (s.x * k + tx);
                    const dy = (d.y * k + ty) - (s.y * k + ty);
                    return Math.sqrt(dx*dx + dy*dy) < (d.r * k + s.r * k) * 0.8;
                });
                if (!overlap) shown.push(d);
            }
            return shown;
        }

        // Main render function - render only once per call
        function render(rootData, level, vendorName) {
            // Clear only the SVG content, not the entire container
            svg.selectAll('*').remove();
            
            const root = d3.hierarchy(rootData)
                .sum(d => d.value)
                .sort((a, b) => b.value - a.value);
            const pack = d3.pack()
                .size([width, height])
                .padding(5);
            pack(root);

            const g = svg.append('g');

            // Bubbles with animated appearance
            const node = g.selectAll('circle')
                .data(root.leaves())
                .enter().append('circle')
                .attr('class', 'node node--leaf')
                .attr('fill', d => {
                    if (level === 'vendor') {
                        return d3.schemeCategory10[d.data.name.length % 10];
                    } else {
                        // Color products based on risk factors
                        const productData = d.data.productData;
                        if (productData && productData.cvss_scores) {
                            const maxCvss = Math.max(...productData.cvss_scores);
                            if (maxCvss >= 9) return '#dc3545'; // Critical - Red
                            if (maxCvss >= 7) return '#fd7e14'; // High - Orange  
                            if (maxCvss >= 4) return '#ffc107'; // Medium - Yellow
                            return '#28a745'; // Low - Green
                        }
                        return d3.interpolateCool(1 - d.data.value / root.leaves()[0].data.value);
                    }
                })
                .attr('cx', d => d.x)
                .attr('cy', d => d.y)
                .attr('r', 0)
                .style('filter', 'drop-shadow(0 2px 8px rgba(0,0,0,0.2))')
                .transition()
                .duration(800)
                .ease(d3.easeElastic)
                .attr('r', d => d.r);

            // Add interactive events after transition
            setTimeout(() => {
                g.selectAll('circle')
                    .data(root.leaves())
                    .on('mouseover', function(event, d) {
                        d3.select(this)
                            .transition()
                            .duration(200)
                            .attr('r', d.r * 1.08);
                        tooltip.transition().duration(200).style('opacity', 0.95);
                        
                        if (level === 'vendor') {
                            tooltip.html(
                                `<strong>Vendor:</strong> ${d.data.name}<br>` +
                                `<strong>Total Count:</strong> ${d.data.value}`
                            );
                        } else {
                            const productData = d.data.productData;
                            let tooltipContent = `<strong>Product:</strong> ${d.data.name}<br>` +
                                               `<strong>Count:</strong> ${d.data.value}<br>` +
                                               `<strong>Vendor:</strong> ${d.data.vendor}`;
                            
                            if (productData) {
                                if (productData.cvss_scores && productData.cvss_scores.length > 0) {
                                    const maxCvss = Math.max(...productData.cvss_scores);
                                    const minCvss = Math.min(...productData.cvss_scores);
                                    tooltipContent += `<br><strong>CVSS Range:</strong> ${minCvss.toFixed(1)} - ${maxCvss.toFixed(1)}`;
                                }
                                if (productData.epss_scores && productData.epss_scores.length > 0) {
                                    const maxEpss = Math.max(...productData.epss_scores);
                                    const minEpss = Math.min(...productData.epss_scores);
                                    tooltipContent += `<br><strong>EPSS Range:</strong> ${minEpss.toFixed(3)} - ${maxEpss.toFixed(3)}`;
                                }
                                if (productData.exploit_maturity && productData.exploit_maturity.values) {
                                    tooltipContent += `<br><strong>Exploit Types:</strong> ${productData.exploit_maturity.values.join(', ')}`;
                                }
                            }
                            
                            tooltip.html(tooltipContent);
                        }
                        tooltip.style('left', (event.pageX + 20) + 'px')
                               .style('top', (event.pageY - 30) + 'px');
                    })
                    .on('mousemove', function(event) {
                        tooltip.style('left', (event.pageX + 20) + 'px')
                               .style('top', (event.pageY - 30) + 'px');
                    })
                    .on('mouseout', function(event, d) {
                        d3.select(this)
                            .transition()
                            .duration(200)
                            .attr('r', d.r);
                        tooltip.transition().duration(300).style('opacity', 0);
                    })
                    .on('click', function(event, d) {
                        if (level === 'vendor') {
                            currentLevel = 'product';
                            currentVendor = d.data.name;
                            render(getProductRoot(currentVendor), 'product', currentVendor);
                        }
                    });
            }, 800); // Wait for animation to complete

            // Labels
            let transform = {k: 1, x: 0, y: 0};
            let leaves = root.leaves();
            let visibleLabels = getNonOverlappingLabels(leaves, transform);

            const label = g.selectAll('text')
                .data(leaves)
                .enter().append('text')
                .attr('x', d => d.x)
                .attr('y', d => d.y)
                .attr('text-anchor', 'middle')
                .attr('alignment-baseline', 'middle')
                .style('pointer-events', 'auto')
                .style('fill', '#fff')
                .style('font-weight', 'bold')
                .style('text-shadow', '0 1px 4px #000, 0 0px 8px #000')
                .text(d => level === 'vendor' ? d.data.name : '')
                .style('font-size', d => {
                    let k = transform.k || 1;
                    return (getFittedFontSize(d.data.name, d.r * 0.85) / k) + 'px';
                })
                .style('opacity', d => (level === 'vendor' && visibleLabels.includes(d) && d.r > 18) ? 1 : 0);

            // Label interactions
            g.selectAll('text')
                .on('mouseover', function(event, d) {
                    if (level === 'vendor') {
                        label.transition().duration(200).style('opacity', l => l === d ? 1 : 0.2);
                        d3.select(this).raise();
                    }
                })
                .on('mouseout', function(event, d) {
                    if (level === 'vendor') {
                        let k = transform.k;
                        let visibleLabels = getNonOverlappingLabels(leaves, transform);
                        label.transition().duration(200).style('opacity', l => {
                            if (visibleLabels.includes(l) && l.r * k > 18) return 1;
                            if (l.data.value < 100 && l === d) return 1;
                            return 0.2;
                        });
                    }
                });

            // Back button for product level
            if (level === 'product') {
                svg.append('text')
                    .attr('x', 20)
                    .attr('y', 30)
                    .attr('fill', '#0074D9')
                    .attr('font-size', '18px')
                    .attr('cursor', 'pointer')
                    .style('transition', 'fill 0.3s, font-size 0.3s')
                    .style('opacity', 0)
                    .text(' Back to Vendors')
                    .on('click', function() {
                        currentLevel = 'vendor';
                        currentVendor = null;
                        render(getVendorRoot(), 'vendor', null);
                    })
                    .on('mouseover', function() {
                        d3.select(this)
                            .style('fill', '#005fa3')
                            .style('font-size', '21px');
                    })
                    .on('mouseout', function() {
                        d3.select(this)
                            .style('fill', '#0074D9')
                            .style('font-size', '18px');
                    })
                    .transition()
                    .duration(600)
                    .style('opacity', 1);
            }

            // Zoom functionality
            const zoom = d3.zoom()
                .scaleExtent([1, 40])
                .on('zoom', function(event) {
                    g.attr('transform', event.transform);
                    transform = event.transform;
                    let k = transform.k;
                    let leaves = root.leaves();
                    let visibleLabels = getNonOverlappingLabels(leaves, transform);
                    label.text(d => d.data.name)
                        .style('font-size', d => (getFittedFontSize(d.data.name, d.r * 0.85) / k) + 'px')
                        .attr('x', d => d.x)
                        .attr('y', d => d.y)
                        .transition()
                        .duration(200)
                        .style('opacity', d => visibleLabels.includes(d) && d.r > 18 ? 1 : 0.2);
                });
            svg.call(zoom);
        }

        // Initial render: show vendors only (SINGLE GROUP - FIXED DEFAULT)
        render(getVendorRoot(), 'vendor', null);
        
    } catch (error) {
        console.error('Error creating vendor bubble chart:', error);
        d3.select('#vendor-bubble-container')
            .append('p')
            .style('text-align', 'center')
            .style('color', '#dc3545')
            .style('font-size', '14px')
            .style('margin', '20px')
            .text('Error loading vendor data');
    } finally {
        // Reset the running flag after a short delay to ensure proper cleanup
        setTimeout(() => {
            createVendorBubbleChart.isRunning = false;
        }, 100);
    }
}

// CVE Risk Dashboard Heatmap
let allRiskData = [];
let riskWindowSize = 20;

// Utility to get heatmap data for Plotly
function getHeatmapTrace(data, windowSize) {
    const windowData = data.slice(0, windowSize);
    
    // Find min and max risk scores for proper scaling
    const riskScores = windowData.map(d => d.Risk_Score);
    const minRisk = Math.min(...riskScores);
    const maxRisk = Math.max(...riskScores);
    
    const y = windowData.map(d => d['CVE-ID']);
    const z = windowData.map(d => [d.Risk_Score]);
    const text = windowData.map(d => [`CVE: ${d['CVE-ID']}<br>Risk Score: ${d.Risk_Score.toFixed(1)}`]);
    
    return {
        z,
        x: ['Total Risk'],
        y,
        text,
        type: 'heatmap',
        colorscale: [
            [0, 'yellow'],   // Low risk values get yellow
            [0.5, 'orange'], // Medium risk values get orange
            [1, 'red']       // High risk values get red
        ],
        zmin: minRisk,     // Set explicit min for color scaling
        zmax: maxRisk,     // Set explicit max for color scaling
        hoverongaps: false,
        hovertemplate: '%{text}<extra></extra>',
        showscale: true,
        colorbar: {
            title: 'Risk Score',
            titleside: 'right',
            tickmode: 'linear',
            tick0: minRisk,
            dtick: (maxRisk - minRisk) / 5
        }
    };
}

// Draw CVE Risk heatmap
function drawCVERiskHeatmap() {
    if (!allRiskData || allRiskData.length === 0) return;
    
    const heatmapTrace = getHeatmapTrace(allRiskData, riskWindowSize);
    const heatmapLayout = {
        title: `CVE Risk Score Heatmap (Top ${riskWindowSize} CVEs)`,
        xaxis: {title: '', showticklabels: false},
        yaxis: {
            title: 'CVE-ID', 
            automargin: true,
            autorange: 'reversed'  // This ensures the first item (highest risk) appears at top
        },
        height: 40 + 30 * riskWindowSize,
        margin: {l: 120, r: 80, t: 60, b: 40},
        transition: {duration: 500, easing: 'cubic-in-out'},
        font: {
            size: 12
        }
    };
    
    Plotly.react('cve-risk-heatmap', [heatmapTrace], heatmapLayout, {responsive: true});
    document.getElementById('windowValueSlider').textContent = riskWindowSize;
}

// Initialize CVE Risk Dashboard
function initializeCVERiskDashboard() {
    // URL to the GitHub JSON file
    const githubJsonUrl = 'data/risk.json';
    
    fetch(githubJsonUrl)
        .then(response => response.json())
        .then(data => {
            allRiskData = data;
            drawCVERiskHeatmap();
            updateWindowSliderDisplay();
        })
        .catch(error => {
            console.error('Error loading CVE risk data:', error);
            // Show error message in the heatmap container
            document.getElementById('cve-risk-heatmap').innerHTML = 
                '<div style="text-align: center; padding: 50px; color: #666;">Error loading CVE risk data. Please check your connection.</div>';
        });

    // Handle slider for window size
    const windowSlider = document.getElementById('windowRange');
    if (windowSlider) {
        windowSlider.addEventListener('input', function() {
            riskWindowSize = parseInt(this.value);
            updateWindowSliderDisplay();
            drawFilteredCVERiskHeatmap();
        });
    }
}

// Update window slider display
function updateWindowSliderDisplay() {
    const sliderValue = document.getElementById('windowValueSlider');
    if (sliderValue) {
        sliderValue.textContent = riskWindowSize;
    }
}

// Vulnerability Trends Chart - Updated to handle both API data and local data formats
function createVulnerabilityTrendsChart() {
    // Use API data if available, otherwise fall back to processed global data
    const data = vulnerabilityTrendsData.length > 0 ? vulnerabilityTrendsData : globalData;
    
    if (!data || data.length === 0) {
        console.warn('No data available for vulnerability trends chart');
        return;
    }

    // Process data for trends (group by month)
    const monthlyData = {};
    
    data.forEach(item => {
        let date;
        if (vulnerabilityTrendsData.length > 0) {
            // API data format
            date = new Date(item.published_date);
        } else {
            // Local data format
            date = new Date(item.publishedDate);
        }
        
        const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
        
        if (!monthlyData[monthKey]) {
            monthlyData[monthKey] = {
                month: monthKey,
                count: 0,
                critical: 0,
                high: 0,
                medium: 0,
                low: 0
            };
        }
        
        monthlyData[monthKey].count++;
        
        // Handle severity based on data source
        let severity;
        if (vulnerabilityTrendsData.length > 0) {
            severity = item.severity?.toLowerCase() || 'unknown';
        } else {
            severity = item.severity?.toLowerCase() || 'unknown';
        }
        
        if (severity === 'critical') monthlyData[monthKey].critical++;
        else if (severity === 'high') monthlyData[monthKey].high++;
        else if (severity === 'medium') monthlyData[monthKey].medium++;
        else if (severity === 'low') monthlyData[monthKey].low++;
    });

    // Convert monthly data to array format for chart
    const chartData = Object.values(monthlyData).sort((a, b) => a.month.localeCompare(b.month));
    
    // Update the existing chart creation code to use chartData
    // ...
}

// Update summary statistics
function updateSummaryStats(data) {
    const filteredData = filterData(data);
    
    // Update total vulnerabilities count
    const totalElement = document.getElementById('total-vulnerabilities');
    if (totalElement) {
        totalElement.textContent = filteredData.length;
    }
    
    // Update severity counts
    const severityCounts = {
        critical: 0,
        high: 0,
        medium: 0,
        low: 0
    };
    
    filteredData.forEach(item => {
        const severity = item.severity?.toLowerCase();
        if (severityCounts.hasOwnProperty(severity)) {
            severityCounts[severity]++;
        }
    });
    
    // Update UI elements
    const criticalElement = document.getElementById('critical-count');
    const highElement = document.getElementById('high-count');
    const mediumElement = document.getElementById('medium-count');
    const lowElement = document.getElementById('low-count');
    
    if (criticalElement) criticalElement.textContent = severityCounts.critical;
    if (highElement) highElement.textContent = severityCounts.high;
    if (mediumElement) mediumElement.textContent = severityCounts.medium;
    if (lowElement) lowElement.textContent = severityCounts.low;
    
    // Update CISA KEV counts
    const cisaYesCount = filteredData.filter(item => item.cisa_kev === 'yes').length;
    const cisaNoCount = filteredData.filter(item => item.cisa_kev === 'no').length;
    
    const cisaYesElement = document.getElementById('cisa-yes-count');
    const cisaNoElement = document.getElementById('cisa-no-count');
    
    if (cisaYesElement) cisaYesElement.textContent = cisaYesCount;
    if (cisaNoElement) cisaNoElement.textContent = cisaNoCount;
}

// Enhanced CVE Risk Dashboard with all filters applied
function initializeEnhancedCVERiskDashboard() {
    // Load risk data with all filters from risk.html
    fetch('data/risk.json')
        .then(response => response.json())
        .then(data => {
            allRiskData = data;
            
            // Apply all filters from risk.html format
            setupRiskFilters();
            
            // Initial draw
            applyRiskFiltersAndDraw();
        })
        .catch(error => {
            console.error('Error loading CVE risk data:', error);
            const heatmapContainer = document.getElementById('cve-risk-heatmap');
            if (heatmapContainer) {
                heatmapContainer.innerHTML = 
                    '<div style="text-align: center; padding: 50px; color: #666;">Error loading CVE risk data. Please check your connection.</div>';
            }
        });
}

// Setup risk filters based on risk.html structure
function setupRiskFilters() {
    // Date type filter (Published vs Last Modified)
    const dateTypeRadios = document.querySelectorAll('input[name="dateType"]');
    dateTypeRadios.forEach(radio => {
        radio.addEventListener('change', applyRiskFiltersAndDraw);
    });
    
    // Date range inputs
    const dateFromInput = document.getElementById('dateFrom');
    const dateToInput = document.getElementById('dateTo');
    if (dateFromInput) dateFromInput.addEventListener('change', applyRiskFiltersAndDraw);
    if (dateToInput) dateToInput.addEventListener('change', applyRiskFiltersAndDraw);
    
    // Exploit maturity checkboxes
    const exploitCheckboxes = document.querySelectorAll('input[id^="exploit"]');
    exploitCheckboxes.forEach(checkbox => {
        checkbox.addEventListener('change', applyRiskFiltersAndDraw);
    });
    
    // Geography checkboxes
    const geoCheckboxes = document.querySelectorAll('input[id^="geo"]');
    geoCheckboxes.forEach(checkbox => {
        checkbox.addEventListener('change', applyRiskFiltersAndDraw);
    });
    
    // CISA KEV radio buttons
    const cisaRadios = document.querySelectorAll('input[name="cisaKev"]');
    cisaRadios.forEach(radio => {
        radio.addEventListener('change', applyRiskFiltersAndDraw);
    });
    
    // Score range inputs
    const cvssMin = document.getElementById('cvssMin');
    const cvssMax = document.getElementById('cvssMax');
    const epssMin = document.getElementById('epssMin');
    const epssMax = document.getElementById('epssMax');
    const riskMin = document.getElementById('riskMin');
    const riskMax = document.getElementById('riskMax');
    
    [cvssMin, cvssMax, epssMin, epssMax, riskMin, riskMax].forEach(input => {
        if (input) {
            input.addEventListener('input', applyRiskFiltersAndDraw);
        }
    });
    
    // Window size slider
    const windowSlider = document.getElementById('windowRange');
    if (windowSlider) {
        windowSlider.addEventListener('input', function() {
            riskWindowSize = parseInt(this.value);
            updateWindowSliderDisplay();
            drawFilteredCVERiskHeatmap();
        });
    }
}

// Parse date function for risk data (handles DD-MM-YYYY format)
function parseRiskDate(dateStr) {
    if (!dateStr) return null;
    
    // Handle DD-MM-YYYY format
    if (dateStr.includes('-') && dateStr.split('-')[0].length === 2) {
        const parts = dateStr.split('-');
        return new Date(`${parts[2]}-${parts[1]}-${parts[0]}`);
    }
    
    // Handle other formats
    return new Date(dateStr);
}

// Apply all risk filters and redraw heatmap
function applyRiskFiltersAndDraw() {
    if (!allRiskData || allRiskData.length === 0) return;
    
    // Get current filter values
    const dateType = document.querySelector('input[name="dateType"]:checked')?.value || 'published';
    const dateFrom = document.getElementById('dateFrom')?.value;
    const dateTo = document.getElementById('dateTo')?.value;
    
    const exploitMaturity = Array.from(document.querySelectorAll('input[id^="exploit"]:checked')).map(cb => cb.value);
    const geography = Array.from(document.querySelectorAll('input[id^="geo"]:checked')).map(cb => cb.value);
    const cisaKev = document.querySelector('input[name="cisaKev"]:checked')?.value || 'all';
    
    const cvssMin = parseFloat(document.getElementById('cvssMin')?.value) || 0;
    const cvssMax = parseFloat(document.getElementById('cvssMax')?.value) || 10;
    const epssMin = parseFloat(document.getElementById('epssMin')?.value) || 0;
    const epssMax = parseFloat(document.getElementById('epssMax')?.value) || 1;
    const riskMin = parseFloat(document.getElementById('riskMin')?.value) || 0;
    const riskMax = parseFloat(document.getElementById('riskMax')?.value) || 100;
    
    // Filter the risk data
    const filteredRiskData = allRiskData.filter(item => {
        // Date filter
        if (dateFrom || dateTo) {
            const itemDateStr = dateType === 'published' ? item.Published : item['Last Modified'];
            const itemDate = parseRiskDate(itemDateStr);
            
            if (dateFrom && itemDate && itemDate < new Date(dateFrom)) return false;
            if (dateTo && itemDate && itemDate > new Date(dateTo)) return false;
        }
        
        // Exploit Maturity filter
        if (exploitMaturity.length > 0 && !exploitMaturity.includes(item['Exploit Maturity'] || '')) return false;
        
        // Geography filter
        if (geography.length > 0 && !geography.includes(item.Geography || '')) return false;
        
        // CISA KEV filter
        if (cisaKev !== 'all' && item['CISA KEV'] !== cisaKev) return false;
        
        // CVSS Score filter
        const cvssScore = parseFloat(item.CVSS_Numeric) || 0;
        if (cvssScore < cvssMin || cvssScore > cvssMax) return false;
        
        // EPSS Score filter
        const epssScore = parseFloat(item.EPSS_Numeric) || 0;
        if (epssScore < epssMin || epssScore > epssMax) return false;
        
        // Risk Score filter
        const riskScore = parseFloat(item.Risk_Score) || 0;
        if (riskScore < riskMin || riskScore > riskMax) return false;
        
        return true;
    });
    
    // Sort by Risk Score descending
    filteredRiskData.sort((a, b) => (b.Risk_Score || 0) - (a.Risk_Score || 0));
    
    // Update filtered data and redraw
    allRiskData = filteredRiskData;
    updateRiskStats(filteredRiskData);
    drawFilteredCVERiskHeatmap();
}

// Update risk statistics
function updateRiskStats(data) {
    const totalElement = document.getElementById('filteredCves');
    const criticalElement = document.getElementById('criticalCount');
    const highElement = document.getElementById('highCount');
    
    if (totalElement) totalElement.textContent = data.length;
    
    const criticalCount = data.filter(item => item.Risk_Category === 'Critical').length;
    const highCount = data.filter(item => item.Risk_Category === 'High').length;
    
    if (criticalElement) criticalElement.textContent = criticalCount;
    if (highElement) highElement.textContent = highCount;
}

// Draw filtered CVE Risk heatmap with enhanced trace
function drawFilteredCVERiskHeatmap() {
    if (!allRiskData || allRiskData.length === 0) {
        const heatmapContainer = document.getElementById('cve-risk-heatmap');
        if (heatmapContainer) {
            heatmapContainer.innerHTML = '<div style="text-align: center; padding: 50px; color: #666;">No data available for current filters</div>';
        }
        return;
    }
    
    const windowData = allRiskData.slice(0, riskWindowSize);
    
    if (windowData.length === 0) {
        const heatmapContainer = document.getElementById('cve-risk-heatmap');
        if (heatmapContainer) {
            heatmapContainer.innerHTML = '<div style="text-align: center; padding:  50px; color: #666;">No results match the current filters</div>';
        }
        return;
    }
    
    const riskScores = windowData.map(d => d.Risk_Score || 0);
    const minRisk = Math.min(...riskScores);
    const maxRisk = Math.max(...riskScores);
    
    const y = windowData.map(d => d['CVE-ID']);
    const z = windowData.map(d => [d.Risk_Score || 0]);
    const text = windowData.map(d => {
        return [`CVE: ${d['CVE-ID']}<br>Risk Score: ${(d.Risk_Score || 0).toFixed(1)}<br>Category: ${d.Risk_Category}<br>CVSS: ${d.CVSS_Numeric || 0}<br>EPSS: ${(d.EPSS_Numeric || 0).toFixed(3)}<br>Geography: ${d.Geography || 'N/A'}<br>Exploit: ${d['Exploit Maturity'] || 'N/A'}<br>CISA KEV: ${d['CISA KEV'] || 'N/A'}`];
    });
    
    const heatmapTrace = {
        z,
        x: ['Risk Score'],
        y,
        text,
        type: 'heatmap',
        colorscale: [
            [0, '#FFF3CD'],     // Light yellow for low risk
            [0.3, '#FFE69C'],   // Yellow
            [0.6, '#FFAB40'],   // Orange
            [0.8, '#FF7043'],   // Red-orange
            [1, '#D32F2F']      // Dark red for high risk
        ],
        zmin: minRisk,
        zmax: maxRisk > minRisk ? maxRisk : minRisk + 1,
        hoverongaps: false,
        hovertemplate: '%{text}<extra></extra>',
        showscale: true,
        colorbar: {
            title: 'Risk Score',
            titleside: 'right',
            tickmode: 'linear',
            tick0: minRisk,
            dtick: maxRisk > minRisk ? (maxRisk - minRisk) / 5 : 1
        }
    };
    
    const heatmapLayout = {
        title: `CVE Risk Score Heatmap (Top ${Math.min(riskWindowSize, allRiskData.length)} of ${allRiskData.length} filtered CVEs)`,
        xaxis: {title: '', showticklabels: false},
        yaxis: {
            title: 'CVE-ID', 
            automargin: true,
            autorange: 'reversed'
        },
        height: Math.max(400, 40 + 30 * Math.min(riskWindowSize, allRiskData.length)),
        margin: {l: 150, r: 80, t: 60, b: 40},
        transition: {duration: 500, easing: 'cubic-in-out'}
    };
    
    const heatmapContainer = document.getElementById('cve-risk-heatmap');
    if (heatmapContainer) {
        Plotly.react('cve-risk-heatmap', [heatmapTrace], heatmapLayout, {responsive: true});
    }
    
    updateWindowSliderDisplay();
}

// Initialize all visualizations
async function initializeDashboard() {
    try {
        // Fetch and process main data
        const data = await fetchData();
        
        if (data && data.length > 0) {
            // Setup filter handlers
            setupFilterHandlers();
            
            // Create initial visualizations
            createVulnerabilityTrends(data);
            createAttackVectorChart(data);
            createCVSSDistributionChart(data);
            createVendorBubbleChart(data);
            updateSummaryStats(data);
            
            // Initialize enhanced CVE Risk Dashboard with filtering
            initializeEnhancedCVERiskDashboard();
            
            console.log('Dashboard initialized successfully');
        } else {
            console.error('No data available for dashboard');
        }
    } catch (error) {
        console.error('Error initializing dashboard:', error);
    }
}

// Export functions for global access
window.initializeDashboard = initializeDashboard;
window.updateVisualization = updateVisualization;
window.setupFilterHandlers = setupFilterHandlers;
window.initializeEnhancedCVERiskDashboard = initializeEnhancedCVERiskDashboard;
window.applyRiskFiltersAndDraw = applyRiskFiltersAndDraw;
